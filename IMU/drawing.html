<!DOCTYPE html>
<html lang="zh-CN">
<head>
<meta charset="UTF-8">
<title>å°è½¦è½¨è¿¹å®æ—¶æ˜¾ç¤º (ç²¾ç¡®æ§åˆ¶ç‰ˆ)</title>
<style>
  #canvas {
    border: 1px solid black;
    background-color: #fafafa;
  }
</style>
</head>
<body>
<h2>ğŸš— å°è½¦è½¨è¿¹ (ç²¾ç¡®æ§åˆ¶ç‰ˆ)</h2>
<p>ç”»å¸ƒå°†è‡ªåŠ¨ç¼©æ”¾ã€‚è¿åŠ¨é€»è¾‘ï¼šè½¬å‘æ—¶æ— ä½ç§»ï¼Œç›´è¡Œæ—¶æ— è½¬å‘ã€‚</p>
<canvas id="canvas" width="800" height="600"></canvas>

<script src="https://cdnjs.cloudflare.com/ajax/libs/paho-mqtt/1.1.0/paho-mqtt.min.js"></script>
<script>
const canvas = document.getElementById("canvas");
const ctx = canvas.getContext("2d");

// --- é…ç½®é€‰é¡¹ ---
const autoScale = true;
const fixedScale = 5;
const padding = 50;

// --- è½¨è¿¹æ•°æ® ---
const trajectory = [{ x: 0, y: 0, theta: 0 }]; // å¢åŠ thetaåˆå§‹å€¼
let bounds = { minX: 0, maxX: 0, minY: 0, maxY: 0 };

// --- å°è½¦çŠ¶æ€ ---
let lastTime = null;
let lastEncoderLeft = null, lastEncoderRight = null;


function redrawCanvas() {
  ctx.clearRect(0, 0, canvas.width, canvas.height);

  let scale;
  if (autoScale) {
    const trajWidth = bounds.maxX - bounds.minX;
    const trajHeight = bounds.maxY - bounds.minY;
    const scaleX = (canvas.width - padding * 2) / trajWidth;
    const scaleY = (canvas.height - padding * 2) / trajHeight;
    scale = Math.min(scaleX, scaleY);
    if (!isFinite(scale)) {
        scale = fixedScale;
    }
  } else {
    scale = fixedScale;
  }

  const trajCenterX = (bounds.minX + bounds.maxX) / 2;
  const trajCenterY = (bounds.minY + bounds.maxY) / 2;
  const offsetX = (canvas.width / 2) - (trajCenterX * scale);
  const offsetY = (canvas.height / 2) + (trajCenterY * scale);

  ctx.beginPath();
  ctx.strokeStyle = "blue";
  ctx.lineWidth = 2;

  trajectory.forEach((point, index) => {
    const canvasX = point.x * scale + offsetX;
    const canvasY = canvas.height - (point.y * scale + (offsetY - canvas.height));

    if (index === 0) {
      ctx.moveTo(canvasX, canvasY);
    } else {
      ctx.lineTo(canvasX, canvasY);
    }
  });
  ctx.stroke();
}


function updateState(data) {
  // ç¡®ä¿å…³é”®æ•°æ®å­˜åœ¨
  if (data.timestamp === undefined || data.encoder_left === undefined || data.encoder_right === undefined || data.command === undefined) {
    return;
  }

  const timestamp = new Date(data.timestamp).getTime();
  if (lastTime === null) {
    lastTime = timestamp;
    lastEncoderLeft = data.encoder_left;
    lastEncoderRight = data.encoder_right;
    return;
  }

  const dt = (timestamp - lastTime) / 1000.0;
  lastTime = timestamp;

  if (dt <= 0) return;

  const deltaEncoderL = data.encoder_left - lastEncoderLeft;
  const deltaEncoderR = data.encoder_right - lastEncoderRight;
  lastEncoderLeft = data.encoder_left;
  lastEncoderRight = data.encoder_right;
  
  const lastPoint = trajectory[trajectory.length - 1];
  const currentTheta = lastPoint.theta || 0;

  // --- æ ¸å¿ƒé€»è¾‘ï¼šæ ¹æ®æŒ‡ä»¤å†³å®šé€Ÿåº¦å’Œè§’é€Ÿåº¦ ---
  let v = 0;     // é»˜è®¤çº¿é€Ÿåº¦ä¸º 0
  let omega = 0; // é»˜è®¤è§’é€Ÿåº¦ä¸º 0

  if (data.command === 'L' || data.command === 'R') {
    // è½¬å‘æŒ‡ä»¤ (L/R): åªæ”¹å˜è§’åº¦ï¼Œä¸äº§ç”Ÿä½ç§»
    omega = (data.command === 'L' ? data.angular_velocity : -data.angular_velocity) || 0;
    // v ä¿æŒä¸º 0

  } else if (data.command === 'F' || data.command === 'B') {
    // ç›´è¡Œ/åé€€æŒ‡ä»¤ (F/B): åªäº§ç”Ÿä½ç§»ï¼Œä¸æ”¹å˜è§’åº¦
    const deltaDistance = (deltaEncoderL + deltaEncoderR) / 2.0;
    v = deltaDistance / dt;
    // omega ä¿æŒä¸º 0
  
  }
  // å¯¹äºåœæ­¢æŒ‡ä»¤ 'S', v å’Œ omega éƒ½å°†ä¿æŒä¸º 0ï¼Œå°è½¦å®Œå…¨é™æ­¢ã€‚

  // --- æ ¹æ®ä¸Šé¢è®¡ç®—å‡ºçš„ v å’Œ omega æ›´æ–°çŠ¶æ€ ---
  const newTheta = currentTheta + (omega * dt);
  
  // ä½¿ç”¨å¹³å‡è§’åº¦æé«˜ä½ç§»è®¡ç®—çš„ç²¾åº¦
  const avgTheta = (currentTheta + newTheta) / 2;
  const newX = lastPoint.x + (v * Math.cos(avgTheta) * dt);
  const newY = lastPoint.y + (v * Math.sin(avgTheta) * dt);
  // --- é€»è¾‘ç»“æŸ ---

  trajectory.push({ x: newX, y: newY, theta: newTheta });
  
  bounds.minX = Math.min(bounds.minX, newX);
  bounds.maxX = Math.max(bounds.maxX, newX);
  bounds.minY = Math.min(bounds.minY, newY);
  bounds.maxY = Math.max(bounds.maxY, newY);

  redrawCanvas();
}


// --- MQTT è¿æ¥éƒ¨åˆ† ---
const client = new Paho.Client("localhost", 9001, "clientId-" + Math.random());

client.onConnectionLost = function (responseObject) {
  console.error("ğŸ”Œ è¿æ¥ä¸¢å¤±:", responseObject.errorMessage);
};

client.onMessageArrived = function (message) {
  try {
    const data = JSON.parse(message.payloadString);
    updateState(data);
  } catch (e) {
    console.error("âŒ è§£æJSONæ•°æ®å‡ºé”™:", e);
  }
};

client.connect({
  userName: "main",
  password: "sws3009-20",
  onSuccess: () => {
    console.log(`âœ… å·²æˆåŠŸè¿æ¥åˆ° MQTT Broker! å¼€å§‹è®¢é˜… 'robot/data' ä¸»é¢˜ã€‚`);
    client.subscribe("robot/data");
  },
  onFailure: err => {
    console.error("âŒ è¿æ¥å¤±è´¥:", err);
  }
});

// åˆå§‹ç»˜åˆ¶
redrawCanvas();
</script>
</body>
</html>