<!DOCTYPE html>
<html lang="en-US">
<head>
<meta charset="UTF-8">
<title>Trajectoty Real-time drawing</title>
<style>
  #canvas {
    border: 1px solid black;
    background-color: #fafafa;
  }
</style>
</head>
<body>
<h2>Drawing the trajectory of the robot car</h2>
<!-- <p></p> -->
<canvas id="canvas" width="1000" height="600"></canvas>

<script src="https://cdnjs.cloudflare.com/ajax/libs/paho-mqtt/1.1.0/paho-mqtt.min.js"></script>
<script>
const canvas = document.getElementById("canvas");
const ctx = canvas.getContext("2d");

const autoScale = true;
const fixedScale = 5;
const padding = 50;


const trajectory = [{ x: 0, y: 0, theta: 0 }]; 
let bounds = { minX: 0, maxX: 0, minY: 0, maxY: 0 };

let lastTime = null;
let lastEncoderLeft = null, lastEncoderRight = null;


function redrawCanvas() {
  ctx.clearRect(0, 0, canvas.width, canvas.height);

  let scale;
  if (autoScale && trajectory.length > 1) {
    const trajWidth = bounds.maxX - bounds.minX;
    const trajHeight = bounds.maxY - bounds.minY;
    
    // Á°Æ‰øùÊúâÊúÄÂ∞èËæπÁïåÔºåÈÅøÂÖçÈô§Èõ∂ÈîôËØØ
    const minWidth = Math.max(trajWidth, 1);
    const minHeight = Math.max(trajHeight, 1);
    
    const scaleX = (canvas.width - padding * 2) / minWidth;
    const scaleY = (canvas.height - padding * 2) / minHeight;
    scale = Math.min(scaleX, scaleY);
    
    // ÈôêÂà∂ÊúÄÂ§ßÂíåÊúÄÂ∞èÁº©ÊîæÊØî‰æã
    scale = Math.max(Math.min(scale, 100), 1);
  } else {
    scale = fixedScale;
  }

  // ËÆ°ÁÆóËΩ®Ëøπ‰∏≠ÂøÉÁÇπ
  const trajCenterX = (bounds.minX + bounds.maxX) / 2;
  const trajCenterY = (bounds.minY + bounds.maxY) / 2;
  
  // ËÆ°ÁÆóÂÅèÁßªÈáèÔºå‰ΩøËΩ®ËøπÂú®ÁîªÂ∏É‰∏≠ÂøÉ
  const offsetX = canvas.width / 2 - trajCenterX * scale;
  const offsetY = canvas.height / 2 - trajCenterY * scale;

  // ÁªòÂà∂ÁΩëÊ†ºÁ∫øÔºàÂèØÈÄâÔºåÂ∏ÆÂä©ÂÆö‰ΩçÔºâ
  ctx.strokeStyle = "#e0e0e0";
  ctx.lineWidth = 1;
  ctx.beginPath();
  // ÁªòÂà∂‰∏≠ÂøÉÁ∫ø
  ctx.moveTo(canvas.width / 2, 0);
  ctx.lineTo(canvas.width / 2, canvas.height);
  ctx.moveTo(0, canvas.height / 2);
  ctx.lineTo(canvas.width, canvas.height / 2);
  ctx.stroke();

  // ÁªòÂà∂ËΩ®Ëøπ
  if (trajectory.length > 1) {
    ctx.beginPath();
    ctx.strokeStyle = "blue";
    ctx.lineWidth = 3;

    trajectory.forEach((point, index) => {
      const canvasX = point.x * scale + offsetX;
      const canvasY = canvas.height - (point.y * scale + offsetY);

      if (index === 0) {
        ctx.moveTo(canvasX, canvasY);
      } else {
        ctx.lineTo(canvasX, canvasY);
      }
    });
    ctx.stroke();
  }

  // Draw start point
  if (trajectory.length > 0) {
    const startPoint = trajectory[0];
    const startX = startPoint.x * scale + offsetX;
    const startY = canvas.height - (startPoint.y * scale + offsetY);
    
    ctx.fillStyle = "green";
    ctx.beginPath();
    ctx.arc(startX, startY, 6, 0, 2 * Math.PI);
    ctx.fill();
  }

  // Draw current position and direction
  if (trajectory.length > 1) {
    const currentPoint = trajectory[trajectory.length - 1];
    const currentX = currentPoint.x * scale + offsetX;
    const currentY = canvas.height - (currentPoint.y * scale + offsetY);
    
    ctx.fillStyle = "red";
    ctx.beginPath();
    ctx.arc(currentX, currentY, 5, 0, 2 * Math.PI);
    ctx.fill();
    
    // Draw direction arrow
    const arrowLength = 15;
    const arrowX = currentX + Math.cos(currentPoint.theta) * arrowLength;
    const arrowY = currentY - Math.sin(currentPoint.theta) * arrowLength;
    
    ctx.strokeStyle = "red";
    ctx.lineWidth = 2;
    ctx.beginPath();
    ctx.moveTo(currentX, currentY);
    ctx.lineTo(arrowX, arrowY);
    ctx.stroke();
  }


  if (trajectory.length > 0) {
    const currentPoint = trajectory[trajectory.length - 1];
    ctx.fillStyle = "black";
    ctx.font = "12px Arial";
    ctx.fillText(`Position: (${currentPoint.x.toFixed(2)}, ${currentPoint.y.toFixed(2)})`, 10, 20);
    ctx.fillText(`Theta: ${(currentPoint.theta * 180 / Math.PI).toFixed(1)}¬∞`, 10, 35);
    ctx.fillText(`Scale: ${scale.toFixed(2)}x`, 10, 50);
    ctx.fillText(`Points: ${trajectory.length}`, 10, 65);
  }
}

function updateState(data) {
  console.log(data['timestamp'])
  if (data.timestamp === undefined || data.encoder_left === undefined || data.encoder_right === undefined || data.status === undefined) {
    return;
  }

  const timestamp = new Date(data.timestamp).getTime();
  if (lastTime === null) {
    lastTime = timestamp;
    lastEncoderLeft = data.encoder_left;
    lastEncoderRight = data.encoder_right;
    console.log("Initial Timestemp:", lastTime, "Left encoder:", lastEncoderLeft, "Right encoder:", lastEncoderRight);
    return;
  }

  const dt = (timestamp - lastTime) / 1000.0;
  
  if (dt <= 0){
   lastTime = timestamp; 
   return;
  }
  lastTime = timestamp;

  const deltaEncoderL = data.encoder_left - lastEncoderLeft;
  const deltaEncoderR = data.encoder_right - lastEncoderRight;
  lastEncoderLeft = data.encoder_left;
  lastEncoderRight = data.encoder_right;
  
  const lastPoint = trajectory[trajectory.length - 1];
  const currentTheta = lastPoint.theta || 0;

  let omega = 0;

  deltadistance = (deltaEncoderL + deltaEncoderR) / 2.0;

  omega = data.angular_velocity
  
  console.log(dt, "s, Delta-EL:", deltaEncoderL, "Delta-ER:",
   deltaEncoderR,  "omega:", omega.toFixed(2));
   
  const newTheta = currentTheta + (omega * dt);
  const avgTheta = (currentTheta + newTheta) / 2;
  const newX = lastPoint.x + (Math.cos(avgTheta) * deltaEncoderL);
  const newY = lastPoint.y + (Math.sin(avgTheta) * deltaEncoderR);
  
  console.log(`New position: (${newX.toFixed(2)}, ${newY.toFixed(2)}) ËßíÂ∫¶: ${newTheta.toFixed(2)} (ËßíÂ∫¶)`);
  trajectory.push({ x: newX, y: newY, theta: newTheta });
  
  // Êõ¥Êñ∞ËæπÁïå
  bounds.minX = Math.min(bounds.minX, newX);
  bounds.maxX = Math.max(bounds.maxX, newX);
  bounds.minY = Math.min(bounds.minY, newY);
  bounds.maxY = Math.max(bounds.maxY, newY);

  // // ‰øùÊåÅËΩ®ËøπÊï∞ÈáèÂú®ÂêàÁêÜËåÉÂõ¥ÂÜÖÔºàÂèØÈÄâÔºâ
  // if (trajectory.length > 1000) {
  //   trajectory.shift(); // ÁßªÈô§ÊúÄÊóßÁöÑÁÇπ
  // }

  redrawCanvas();
}

const client = new Paho.Client("localhost", 9001, "client-draw-trajectory");

client.onConnectionLost = function (responseObject) {
  console.error("üîå Connection failed:", responseObject.errorMessage);
};

client.onMessageArrived = function (message) {
  try {
    const data = JSON.parse(message.payloadString);
    console.log('üì• Received message:', data);
    updateState(data);
  } catch (e) {
    console.error("‚ùå Parsing JSON failed:", e);
  }
};

client.connect({
  userName: "main",
  password: "sws3009-20",
  onSuccess: () => {
    console.log(`‚úÖ Connected to MQTT Broker! Beginning to subscribe to 'robot/data' topic.`);
    client.subscribe("robot/data");  },
  onFailure: err => {
    console.error("‚ùå Connection failed:", err);
  }
});

redrawCanvas();
</script>
</body>
</html>